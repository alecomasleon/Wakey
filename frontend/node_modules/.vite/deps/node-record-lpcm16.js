import {
  require_assert,
  require_child_process,
  require_path
} from "./chunk-RZKJ3PFK.js";
import "./chunk-PO6W5DPR.js";
import {
  __commonJS,
  __require,
  init_buffer,
  init_process,
  process
} from "./chunk-KMC2FRRU.js";

// ../node_modules/node-record-lpcm16/node_modules/ms/index.js
var require_ms = __commonJS({
  "../node_modules/node-record-lpcm16/node_modules/ms/index.js"(exports, module) {
    init_process();
    init_buffer();
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var y = d * 365.25;
    module.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isNaN(val) === false) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      if (ms >= d) {
        return Math.round(ms / d) + "d";
      }
      if (ms >= h) {
        return Math.round(ms / h) + "h";
      }
      if (ms >= m) {
        return Math.round(ms / m) + "m";
      }
      if (ms >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      return plural(ms, d, "day") || plural(ms, h, "hour") || plural(ms, m, "minute") || plural(ms, s, "second") || ms + " ms";
    }
    function plural(ms, n, name) {
      if (ms < n) {
        return;
      }
      if (ms < n * 1.5) {
        return Math.floor(ms / n) + " " + name;
      }
      return Math.ceil(ms / n) + " " + name + "s";
    }
  }
});

// ../node_modules/node-record-lpcm16/node_modules/debug/src/debug.js
var require_debug = __commonJS({
  "../node_modules/node-record-lpcm16/node_modules/debug/src/debug.js"(exports, module) {
    init_process();
    init_buffer();
    exports = module.exports = createDebug.debug = createDebug["default"] = createDebug;
    exports.coerce = coerce;
    exports.disable = disable;
    exports.enable = enable;
    exports.enabled = enabled;
    exports.humanize = require_ms();
    exports.names = [];
    exports.skips = [];
    exports.formatters = {};
    var prevTime;
    function selectColor(namespace) {
      var hash = 0, i;
      for (i in namespace) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return exports.colors[Math.abs(hash) % exports.colors.length];
    }
    function createDebug(namespace) {
      function debug() {
        if (!debug.enabled) return;
        var self = debug;
        var curr = +/* @__PURE__ */ new Date();
        var ms = curr - (prevTime || curr);
        self.diff = ms;
        self.prev = prevTime;
        self.curr = curr;
        prevTime = curr;
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        args[0] = exports.coerce(args[0]);
        if ("string" !== typeof args[0]) {
          args.unshift("%O");
        }
        var index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
          if (match === "%%") return match;
          index++;
          var formatter = exports.formatters[format];
          if ("function" === typeof formatter) {
            var val = args[index];
            match = formatter.call(self, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        exports.formatArgs.call(self, args);
        var logFn = debug.log || exports.log || console.log.bind(console);
        logFn.apply(self, args);
      }
      debug.namespace = namespace;
      debug.enabled = exports.enabled(namespace);
      debug.useColors = exports.useColors();
      debug.color = selectColor(namespace);
      if ("function" === typeof exports.init) {
        exports.init(debug);
      }
      return debug;
    }
    function enable(namespaces) {
      exports.save(namespaces);
      exports.names = [];
      exports.skips = [];
      var split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      var len = split.length;
      for (var i = 0; i < len; i++) {
        if (!split[i]) continue;
        namespaces = split[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          exports.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
        } else {
          exports.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      exports.enable("");
    }
    function enabled(name) {
      var i, len;
      for (i = 0, len = exports.skips.length; i < len; i++) {
        if (exports.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = exports.names.length; i < len; i++) {
        if (exports.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }
    function coerce(val) {
      if (val instanceof Error) return val.stack || val.message;
      return val;
    }
  }
});

// ../node_modules/node-record-lpcm16/node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "../node_modules/node-record-lpcm16/node_modules/debug/src/browser.js"(exports, module) {
    init_process();
    init_buffer();
    exports = module.exports = require_debug();
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = "undefined" != typeof chrome && "undefined" != typeof chrome.storage ? chrome.storage.local : localstorage();
    exports.colors = [
      "lightseagreen",
      "forestgreen",
      "goldenrod",
      "dodgerblue",
      "darkorchid",
      "crimson"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && window.process.type === "renderer") {
        return true;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    exports.formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (err) {
        return "[UnexpectedJSONParseError]: " + err.message;
      }
    };
    function formatArgs(args) {
      var useColors2 = this.useColors;
      args[0] = (useColors2 ? "%c" : "") + this.namespace + (useColors2 ? " %c" : " ") + args[0] + (useColors2 ? "%c " : " ") + "+" + exports.humanize(this.diff);
      if (!useColors2) return;
      var c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      var index = 0;
      var lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, function(match) {
        if ("%%" === match) return;
        index++;
        if ("%c" === match) {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    function log() {
      return "object" === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
    }
    function save(namespaces) {
      try {
        if (null == namespaces) {
          exports.storage.removeItem("debug");
        } else {
          exports.storage.debug = namespaces;
        }
      } catch (e) {
      }
    }
    function load() {
      var r;
      try {
        r = exports.storage.debug;
      } catch (e) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    exports.enable(load());
    function localstorage() {
      try {
        return window.localStorage;
      } catch (e) {
      }
    }
  }
});

// ../node_modules/node-record-lpcm16/recorders/index.js
var require_recorders = __commonJS({
  "../node_modules/node-record-lpcm16/recorders/index.js"(exports, module) {
    init_process();
    init_buffer();
    var path = require_path();
    function load(recorderName) {
      try {
        const recoderPath = path.resolve(__dirname, recorderName);
        return __require(recoderPath);
      } catch (err) {
        if (err.code === "MODULE_NOT_FOUND") {
          throw new Error(`No such recorder found: ${recorderName}`);
        }
        throw err;
      }
    }
    module.exports = {
      load
    };
  }
});

// ../node_modules/node-record-lpcm16/index.js
var require_node_record_lpcm16 = __commonJS({
  "../node_modules/node-record-lpcm16/index.js"(exports, module) {
    init_process();
    init_buffer();
    var assert = require_assert();
    var debug = require_browser()("record");
    var { spawn } = require_child_process();
    var recorders = require_recorders();
    var Recording = class {
      constructor(options = {}) {
        const defaults = {
          sampleRate: 16e3,
          channels: 1,
          compress: false,
          threshold: 0.5,
          thresholdStart: null,
          thresholdEnd: null,
          silence: "1.0",
          recorder: "sox",
          endOnSilence: false,
          audioType: "wav"
        };
        this.options = Object.assign(defaults, options);
        const recorder = recorders.load(this.options.recorder);
        const { cmd, args, spawnOptions = {} } = recorder(this.options);
        this.cmd = cmd;
        this.args = args;
        this.cmdOptions = Object.assign({ encoding: "binary", stdio: "pipe" }, spawnOptions);
        debug(`Started recording`);
        debug(this.options);
        debug(` ${this.cmd} ${this.args.join(" ")}`);
        return this.start();
      }
      start() {
        const { cmd, args, cmdOptions } = this;
        const cp = spawn(cmd, args, cmdOptions);
        const rec = cp.stdout;
        const err = cp.stderr;
        this.process = cp;
        this._stream = rec;
        cp.on("close", (code) => {
          if (code === 0) return;
          rec.emit(
            "error",
            `${this.cmd} has exited with error code ${code}.

Enable debugging with the environment variable DEBUG=record.`
          );
        });
        err.on("data", (chunk) => {
          debug(`STDERR: ${chunk}`);
        });
        rec.on("data", (chunk) => {
          debug(`Recording ${chunk.length} bytes`);
        });
        rec.on("end", () => {
          debug("Recording ended");
        });
        return this;
      }
      stop() {
        assert(this.process, "Recording not yet started");
        this.process.kill();
      }
      pause() {
        assert(this.process, "Recording not yet started");
        this.process.kill("SIGSTOP");
        this._stream.pause();
        debug("Paused recording");
      }
      resume() {
        assert(this.process, "Recording not yet started");
        this.process.kill("SIGCONT");
        this._stream.resume();
        debug("Resumed recording");
      }
      isPaused() {
        assert(this.process, "Recording not yet started");
        return this._stream.isPaused();
      }
      stream() {
        assert(this._stream, "Recording not yet started");
        return this._stream;
      }
    };
    module.exports = {
      record: (...args) => new Recording(...args)
    };
  }
});
export default require_node_record_lpcm16();
//# sourceMappingURL=node-record-lpcm16.js.map
